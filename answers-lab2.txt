# JOS-Lab 2 Memory Management

叶志晟 1500012804 2017年10月8日

## 概述

lab2的主要内容是通过完成一些直接操作内存管理相关的函数，来对JOS的内存进行管理，主要分为对于物理内存的初始化、分配、回收和虚拟内存的建立、映射与管理两大部分。

第一部分的对物理内存的相关操作必须建立在读懂`memlayout.h`中的内存分配示意图的基础上，要了解`pages`数组的含义与内容，要开始熟悉`PageInfo`结构体的内容，要知道`page_free_list`等较为重要的全局变量表达的信息并在自己写的函数中注意维护这些信息。在第一部分完成后，就可以对物理内存的组织方式有基本的了解。

第一部分基本上按照注释要求完成即可。

第二部分内容比第一部分略多，首先要先了解80386的寻址模式，了解page translation与segment translation和相应的权限管理，了解selector与descriptor在JOS的lab2中，由于没有segment translation主要体现为了解二级页表寻址的相关内容，并通过`mmu.h`与`memlayout.h`中给出的一些全局变量和宏来完成整个虚拟内存的建立。

不得不说lab中给出的各种`panic`与测试非常全面，对以后的测试有很大的启发。一些例如`uintptr_t`与`physaddr_t`、为了保持统一性的`ALLOC_ZERO = 1<<0`的细节也令人感慨于源码的艺术性。

## 任务完成情况

|  No.  |Y/N |
| ---------- | --- |
| Ex1 |  Y |
| Ex2 |  Y |
| Ex3 |  Y |
| Ex4 |  Y |
| Ex5 |  Y |
| Q1 |  Y |
| Q2 |  Y |
| Q3 |  Y |
| Q4 |  Y |
| Q5 |  Y |
| Q6 |  Y |
| C1 |  N |
| C2 |  Y |
| C3 |  Y |
| C4 |  H |

### Ex1

Ex1需要完成五个与直接操作物理内存相关的函数。

- `boot_alloc()`并不直接承担对内存的`alloc`，根据给出的部分可以猜出只需要维护`nextfree`的值使其指向下一个空的内存的物理地址即可，然后返回分配部分的起始地址；

- `mem_init()`此时暂时只需要我们补充一下分配`pages`数组所需空间的部分，根据注释要求用`boot_alloc`占用`pages`数组所需空间并对这片区域`memset`即可；

- `page_init()`需要我们将刚刚的`pages`数组中一共`npages`的内容补充完成，注释中非常友好的告诉了我们这`npages`可以分成哪些部分，然后分别应该是什么内容，稍微要想一下的是第四个部分，在`EXTPHYSEM`之外有一部分是内核已经使用的部分，这一部分与空闲部分的界线可以用刚刚实现的`boot_alloc(0)`函数来求出，因为`boot_alloc`通过维护`nextfree`来直接得到free memory的起始地址，然后我们将其转化为页对应的物理地址，从而知道是第几个页；

- `page_alloc()`中真正进行了`alloc`的操作，也即从`page_free_list`中拉出第一个`page`然后维护一下即可；

- `page_free()`与`page_alloc()`相反，将一个`page`放入`page_free_list`的头中。

### Ex2

![Segment translation](https://pdos.csail.mit.edu/6.828/2016/readings/i386/fig5-2.gif)

描述了segment translation的过程：先从16位的selector中读出对应的descriptor，从而得到base address，与32位的offset相加得到linear address，然后再切分成二级页表和offset。

![Page translation](https://pdos.csail.mit.edu/6.828/2016/readings/i386/fig5-9.gif)

描述了一个linear address如何变为physical address：依次用CR3去page directory与page table中寻找对应的项得到对应的页再根据offset确定最后的内容。

### Ex3

通过qemu中的`xp`与gdb中的`x`查看可以发现结果一致，证明在JOS中linear address与virtual address一致

### Q1

`uintptr_t`。因为用户态代码执行的时候肯定是虚拟地址。

### Ex4

- `pgdir_walk()`是这一部分中的核心内容，目的是找到给定虚拟地址`va`对应的二级页表(PTE)的地址，而且要考虑不存在的情况。如果不存在，需要用`page_alloc`然后修改对应的page directory项，然后记下来刚alloc出来大页的地址，最后加上offset返回回去；如果存在则直接用`mmu.h`中的宏转换一下，同样记得加上offset。然后如果修改page directory的话要加上权限位；

- `boot_map_region()`用于将指定范围的虚拟地址与物理地址做映射。用最纯朴的办法一个page一个page的改对应的PTE的内容，PTE的值通过刚刚完成的`pgdir_walk()`来从虚拟地址推出来，由于是新建一个完整的映射所以create应当置成1；

- `page_lookup()`第三个参数`pte_store`是要存对应pte的值，这个要从调用的地方看出来，注释没有说明但是这个变量名这个意思也不是不可以吧。用于返回给定虚拟地址`va`对应的page，这里只需要将create置成0让他去找即可；

- `page_remove()`相当于删去这个已经map的PTE了，同样是搜索，如果找到了先要对这个页做`page_decref()`然后还要把这个pte项指向`NULL`，最后再按注释中描述的调用一下`tlb_invalidate`相当于做一下tlb的flash，查了一下这个函数里面的`invlpg`然后发现是intel的一个汇编指令，可以用来清除特定页的TLB，所以如果后面有遇到map改变的话都应该做一下这个操作；

- `page_insert()`说是insert其实就是建立一个物理页和虚拟地址的关系，也就是把具体的物理页变成我们可以管理的地址。首先我们看这个虚拟地址上面是不是已经有东西了，有的话要把它remove掉，我一开始先用`create = 0`来walk了一遍，就相当于先lookup一次，同时尽可能保持原来页表不变，然后改一改pte的内容，由于这里重新做了map，如上面所说，做一次`tlb_invalidate`刷新一下tlb。但是正如注释中所说，如果前后给定的page和`va`都相同会直接丢掉这一页，这是不科学的，注释中要求最好能不做特判，这里一开始没有实现。最后全部完成过后开始考虑这里能不能修改，最后在田晶晶同学的帮助下将两次walk改为一次walk，直接做`create = 1`的walk，然后直接先对这个page的`pp_ref`做加一的处理，这样原来如果相同就不会有多余的操作了而且符合注释中elegant的要求。

### Ex5

最后回过头来完成`mem_init()`的部分，显然是要用到刚刚手动完成的函数，是对三个部分page的map和权限的设置，根据注释的说明直接调用三次`boot_map_region()`即可

### Q2

Every PTE points to a continous 4KB PT which points to a 4MB phys memory.

|Entry|Base VA|Points to|
| ---------- | --- | -- |
|1023|`0xffc0000`|top 4MB of phys memory|
|1022|`0xff80000`|second to top 4MB of phys memory|
| … | … | … |
| 960 |`0xf0000000`| KERNBASE |
| 959 |`0xefc00000`| MMIOLIM|
| 958 |`0xef800000`| ULIM, MMIOBASE |
| 957 |`0xef40000`| UVPT |
| 956 |`0xef000000`| UPAGES |
| 955 |`0xeec00000`| UTOP, UENVS, UXSTACKTOP |
| … | … | … |
| 2 |`0x00800000`| UTEXT |
| 1 |`0x00400000`| UTEMP |
| 0 |`0x00000000`| IDT/BIOS |

### Q3

不同页的权限位设置不同保证了这一点，具体来说就是`PTE_U`

### Q4

The size of `struct PageInfo` is 8B. The maximum of page table is `0x00400000` which is 4MB. So the maximum of memory JOS can manage is 0.5M(pages) * 4KB = 2G.

### Q5

The overhead is introduced because of the two-level page management system. There are 1024 * 4KB and one page directory of 4KB. But the PD is recursively inserted in itself as a page table at UVPT as told in `pmap.c`. So the total overhead is just 4MB.

### Q6

After paging on, we want to jump up above KERNBASE(the higher address) using following two lines of codes:

```asm
	mov $relocated, %eax
	jmp *%eax
```

The reason is we not only map [KERNBASE, KERNBASE+4MB) to phys memory [0, 4MB), but also map [0, 4MB) to phys memory [0, 4MB). So it works pretty well.

The transition is necessary because kern_pgdir won't know the true virtual address if not.

###C1

这个challenge需要通过设置CR4寄存器来变成4MB页，然后发现如果要实现的话刚刚所有的针对two-level的寻址都要重写，由于时间关系暂时放弃。

###C2

这个challenge难度并不大，就是实现这三个函数外加参数处理。参数处理部分参考了[Clann24/jos](https://github.com/Clann24/jos/tree/master/lab2)

让JOS执行自己的命令在lab1中已经介绍过，此处唯一不同是要```#include<inc/pmap.h>```

第一个也即用给定的linear address/virtual address去找对应page的权限，直接`pagedir_walk()`然后读出对应的权限位；

第二个设置类似于上面，直接设置；

第三个就要稍微麻烦一点，但是可以投机取巧直接对physical address + KERNBASE来得到对应的virtual address，然后直接访问即可，关于pages的边缘的处理，我是直接ROUNDUP完之后只访问那些对其的页面，应该不违反题目的意思。

###C4

We can use buddy system for allocating greater pages.